{"version":3,"sources":["webpack:///path---posts-here-be-dragons-string-concatenation-b7dab888fa1b46caff75.js","webpack:///./.cache/json/posts-here-be-dragons-string-concatenation.json"],"names":["webpackJsonp","433","module","exports","data","site","siteMetadata","title","subtitle","author","name","twitter","disqusShortname","url","markdownRemark","id","html","fields","tagSlugs","frontmatter","tags","date","description","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,wBAAAC,SAAA,oCAAAC,QAAyFC,KAAA,kBAAAC,QAAA,kBAAoDC,gBAAA,GAAAC,IAAA,yBAAoDC,gBAAmBC,GAAA,sJAAAC,KAAA,g3cAAm9XC,QAAy5FC,UAAA,kCAA6CC,aAAgBZ,MAAA,wCAAAa,MAAA,oBAAAC,KAAA,2BAAAC,YAAA,2XAAsfC,aAAgBC,KAAA","file":"path---posts-here-be-dragons-string-concatenation-b7dab888fa1b46caff75.js","sourcesContent":["webpackJsonp([267124642010291],{\n\n/***/ 433:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"To kill a mocking bug\",\"subtitle\":\"Unearthing curious .NET behaviour\",\"author\":{\"name\":\"Jeroen Vannevel\",\"twitter\":\"VannevelJeroen\"},\"disqusShortname\":\"\",\"url\":\"https://vannevel.net\"}},\"markdownRemark\":{\"id\":\"C:/Source/vannevelj.github.io/lumen/src/pages/articles/2015-09-17--Here-Be-Dragons-String-Concatenation/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Introduction</h1>\\n<p>String concatenation can be done in several ways, each with their own advantages and usecases. In this blogpost I will take a closer look at 4 different ways of concatenating strings and how these are implemented internally. At the end of this post I hope I will have made clear when they are useful, when they are not and how they compare to eachother implementation-wise.</p>\\n<p>The approaches discussed are:</p>\\n<ul>\\n<li>Simple concatenation</li>\\n<li><code class=\\\"language-text\\\">string.Concat()</code></li>\\n<li><code class=\\\"language-text\\\">StringBuilder</code></li>\\n<li><code class=\\\"language-text\\\">string.Join()</code></li>\\n</ul>\\n<h1>Simple concatenation</h1>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\"><span class=\\\"token keyword\\\">string</span> a <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"Hello\\\"</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">\\\"World\\\"</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>String concatenation is commonly done using the <code class=\\\"language-text\\\">+</code> operator and passing one or two strings as its operands. Notice that something like <code class=\\\"language-text\\\">string a = &quot;abc&quot; + new FileLoadException();</code> is perfectly legal: you’ll see in a bit why this is.</p>\\n<p>You might have been wondering what happens exactly when you use this form of concatenation. In order to find out, we have to look at the generated IL code. Now, if you simply look at the generated IL given the string above you will notice that it looks like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">IL_0000: nop\\nIL_0001: ldstr &quot;HelloWorld&quot;\\nIL_0006: stloc.0 // a\\nIL_0007: ret</code></pre>\\n      </div>\\n<p>Because our string concatenation is considered a so-called “compile-time constant expression” the compiler turns it into a single string for us already.</p>\\n<p>We can bypass this optimization by defining it as two separate variables and concatenating these:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\"><span class=\\\"token keyword\\\">string</span> x <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"Hello\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">string</span> y <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"World\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">string</span> a <span class=\\\"token operator\\\">=</span> x <span class=\\\"token operator\\\">+</span> y<span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>Looking at the IL again we now see this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">IL_0000: nop\\nIL_0001: ldstr &quot;Hello&quot;\\nIL_0006: stloc.0 // x\\nIL_0007: ldstr &quot;World&quot;\\nIL_000C: stloc.1 // y\\nIL_000D: ldloc.0 // x\\nIL_000E: ldloc.1 // y\\nIL_000F: call System.String.Concat\\nIL_0014: stloc.2 // a\\nIL_0015: ret</code></pre>\\n      </div>\\n<p>That’s more like it! We can tell from this that first the two strings are loaded into memory (separately!) and, more interestingly, they are put together using the <code class=\\\"language-text\\\">string.Concat()</code> method.</p>\\n<h1>string.Concat()</h1>\\n<p>We’ve seen now that simple string concatenation results in a call to <code class=\\\"language-text\\\">string.Concat()</code>. Depending on the types passed in it will choose between <code class=\\\"language-text\\\">string.Concat(string, string)</code> (in the case of two strings) or <code class=\\\"language-text\\\">string.Concat(object, object)</code> (in the case of only one string). If you’ll replace the simple concatenation with a call to <code class=\\\"language-text\\\">string.Format()</code> you’ll notice that you receive the exact same IL.</p>\\n<p>At this point we can take a look at the internals and what goes on exactly. Looking at <a href=\\\"https://github.com/dotnet/coreclr/blob/d176041723f366c35fd71ee4b176253fefddfee1/src/mscorlib/src/System/String.cs#L3011\\\">the source code</a> of <code class=\\\"language-text\\\">string.Concat(object, object)</code> we can see it is a pass-through to <code class=\\\"language-text\\\">string.Concat(string, string)</code> by calling <code class=\\\"language-text\\\">ToString()</code> on both operands — even if one of these was already a string.</p>\\n<p><a href=\\\"https://github.com/dotnet/coreclr/blob/d176041723f366c35fd71ee4b176253fefddfee1/src/mscorlib/src/System/String.cs#L3141\\\">Our next step</a> is more interesting: after the usual validation handling and fast tracks, we see a few very interesting methods being called:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\"><span class=\\\"token class-name\\\">String</span> result <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">FastAllocateString</span><span class=\\\"token punctuation\\\">(</span>str0Length <span class=\\\"token operator\\\">+</span> str1<span class=\\\"token punctuation\\\">.</span>Length<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">FillStringChecked</span><span class=\\\"token punctuation\\\">(</span>result<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">,</span> str0<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">FillStringChecked</span><span class=\\\"token punctuation\\\">(</span>result<span class=\\\"token punctuation\\\">,</span> str0Length<span class=\\\"token punctuation\\\">,</span> str1<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p><code class=\\\"language-text\\\">FastAllocateString(int)</code> is an external method that will allocate the space needed to concatenate both strings which is evidently the sum of their lengths. Afterwards, <code class=\\\"language-text\\\">FillStringChecked(string, int, string)</code> will copy the contents from the given string (third parameter) at a certain index into the aggregate one we just allocated. At this point the aggregate string is filled and can be returned to the caller. You might have noticed that <code class=\\\"language-text\\\">FastAllocateString</code> returns a string and not a <code class=\\\"language-text\\\">char</code> array. This is important because it changes the way we have to fill it: with a char array we would be able to simply access each entry directly and insert the correct value. However since it is a string we can (have to?) use an unsafe context and pull out some C to copy the contents into the correct memory location. This has as benefit that you don’t have to loop (explicitly) to move the string around.</p>\\n<h2>What about more concatenations?</h2>\\n<p>If you look at the overloads you’ll notice that there are overloads with 2, 3 and 4 parameters and afer that you have to use the one with only one: a collection. We can see this in action when we try to concatenate 5 strings:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\"><span class=\\\"token keyword\\\">string</span> v <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"Strings\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">string</span> w <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"Are\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">string</span> x <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"Fun\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">string</span> y <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"Hello\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">string</span> z <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"World\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">string</span> a <span class=\\\"token operator\\\">=</span> v <span class=\\\"token operator\\\">+</span> w <span class=\\\"token operator\\\">+</span> x <span class=\\\"token operator\\\">+</span> y <span class=\\\"token operator\\\">+</span> z<span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>generates as IL:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">IL_0000:  nop\\nIL_0001:  ldstr       &quot;Strings&quot;\\nIL_0006:  stloc.0     // v\\nIL_0007:  ldstr       &quot;Are&quot;\\nIL_000C:  stloc.1     // w\\nIL_000D:  ldstr       &quot;Fun&quot;\\nIL_0012:  stloc.2     // x\\nIL_0013:  ldstr       &quot;Hello&quot;\\nIL_0018:  stloc.3     // y\\nIL_0019:  ldstr       &quot;World&quot;\\nIL_001E:  stloc.s     04 // z\\nIL_0020:  ldc.i4.5\\nIL_0021:  newarr      System.String\\nIL_0026:  dup\\nIL_0027:  ldc.i4.0\\nIL_0028:  ldloc.0     // v\\nIL_0029:  stelem.ref\\nIL_002A:  dup\\nIL_002B:  ldc.i4.1\\nIL_002C:  ldloc.1     // w\\nIL_002D:  stelem.ref\\nIL_002E:  dup\\nIL_002F:  ldc.i4.2\\nIL_0030:  ldloc.2     // x\\nIL_0031:  stelem.ref\\nIL_0032:  dup\\nIL_0033:  ldc.i4.3\\nIL_0034:  ldloc.3     // y\\nIL_0035:  stelem.ref\\nIL_0036:  dup\\nIL_0037:  ldc.i4.4\\nIL_0038:  ldloc.s     04 // z\\nIL_003A:  stelem.ref\\nIL_003B:  call        System.String.Concat\\nIL_0040:  stloc.s     05 // a\\nIL_0042:  ret</code></pre>\\n      </div>\\n<p>This clearly shows us a new array is created (see instruction <code class=\\\"language-text\\\">IL_0021</code>) which is then passed to the <code class=\\\"language-text\\\">string.Concat()</code> call.\\nThe reason there are these specific overloads for 3 and 4 arguments is performance: the most common scenarios of concatenating values include 2, 3 or 4 operands and as such these are treated separatedly to get performance gains in the majority of cases.</p>\\n<p>For this implementation we have to take a look at the <code class=\\\"language-text\\\">string.Concat(params string[])</code> method. The implementation here is fairly straightforward: just as in the previous methods we calculate the total length of the resulting string and afterwards fill that up with the <code class=\\\"language-text\\\">string.ConcatArray(string[], int)</code> method. Also interesting to notice is the threading consideration by deep-copying the array of strings to a new, local one!</p>\\n<h1>StringBuilder</h1>\\n<p>It’s time to add the notorious <code class=\\\"language-text\\\">StringBuilder</code> to the mix. We’ll work with a very simple scenario:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\"><span class=\\\"token class-name\\\">StringBuilder</span> sb <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">StringBuilder</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nsb<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Append</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Hello\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nsb<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Append</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"World\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">string</span> a <span class=\\\"token operator\\\">=</span> sb<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">ToString</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>A <code class=\\\"language-text\\\">StringBuilder</code> is in essence a wrapper class around an array of chars and each time you append something to it, it inserts the given string’s content (aka: the chars) in the next available space in the <code class=\\\"language-text\\\">StringBuilder</code> array. This follows a similar idea to <code class=\\\"language-text\\\">string.Concat</code> but the big benefit here is that the resulting array is maintained over multiple calls instead of a single call. You might see where I’m going with this: <code class=\\\"language-text\\\">string.Concat()</code> creates a new string object for each call. A <code class=\\\"language-text\\\">StringBuilder</code> however only does this when its <code class=\\\"language-text\\\">ToString()</code> method is called regardless of how often you call <code class=\\\"language-text\\\">StringBuilder.Append()</code>. The more objects you allocate, the more you strain the garbage collector and the sooner you trigger a garbage collection. Nobody likes collecting garbage if it could have been prevented altogether.</p>\\n<p>The obvious real-life scenario is when you use a loop.</p>\\n<h1>string.Join()</h1>\\n<p>Last but not least: <code class=\\\"language-text\\\">string.Join()</code>. Admittedly, this probably isn’t the usecase most people have in mind for this method but since it still fits, I thought it to be interesting to include in this overview. When we look at <a href=\\\"https://github.com/dotnet/coreclr/blob/d176041723f366c35fd71ee4b176253fefddfee1/src/mscorlib/src/System/String.cs#L156\\\">the code</a> we notice something interesting: it uses a <code class=\\\"language-text\\\">StringBuilder</code> internally!</p>\\n<p>I believe you’ll find this to be a common sight: many methods that have to concatenate strings use a StringBuilder internally.</p>\\n<h1>Conclusion</h1>\\n<p>Reflecting on these four approaches we can group them under two actually different ones: <code class=\\\"language-text\\\">string.Concat()</code> and <code class=\\\"language-text\\\">StringBuilder</code>. We’ve also seen that <code class=\\\"language-text\\\">string.Concat()</code> creates a new string each time you concatenate it whereas <code class=\\\"language-text\\\">StringBuilder</code> delays this until the very end and only does it once. On the other hand: constructing a <code class=\\\"language-text\\\">StringBuilder</code> object, adding to it and then retrieving the result is much more verbose than a simple + operator.</p>\\n<p>You will have to decide for yourself what you consider acceptable but I personally only use <code class=\\\"language-text\\\">StringBuilder</code> when I loop over something. If I can do concatenating “manually” and it remains readable then it must mean there are so little strings that it would barely make a difference anyway (don’t forget that the <code class=\\\"language-text\\\">StringBuilder</code> is an object that needs to be allocated as well!).</p>\",\"fields\":{\"tagSlugs\":[\"/tags/c/\",\"/tags/performance/\"]},\"frontmatter\":{\"title\":\"Here be dragons: string concatenation\",\"tags\":[\"C#\",\"Performance\"],\"date\":\"2015-09-17T00:00:00.000Z\",\"description\":\"String concatenation can be done in several ways, each with their own advantages and usecases. In this blogpost I will take a closer look at 4 different ways of concatenating strings and how these are implemented internally. At the end of this post I hope I will have made clear when they are useful, when they are not and how they compare to eachother implementation-wise.\"}}},\"pathContext\":{\"slug\":\"/posts/here-be-dragons-string-concatenation/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---posts-here-be-dragons-string-concatenation-b7dab888fa1b46caff75.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"To kill a mocking bug\",\"subtitle\":\"Unearthing curious .NET behaviour\",\"author\":{\"name\":\"Jeroen Vannevel\",\"twitter\":\"VannevelJeroen\"},\"disqusShortname\":\"\",\"url\":\"https://vannevel.net\"}},\"markdownRemark\":{\"id\":\"C:/Source/vannevelj.github.io/lumen/src/pages/articles/2015-09-17--Here-Be-Dragons-String-Concatenation/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Introduction</h1>\\n<p>String concatenation can be done in several ways, each with their own advantages and usecases. In this blogpost I will take a closer look at 4 different ways of concatenating strings and how these are implemented internally. At the end of this post I hope I will have made clear when they are useful, when they are not and how they compare to eachother implementation-wise.</p>\\n<p>The approaches discussed are:</p>\\n<ul>\\n<li>Simple concatenation</li>\\n<li><code class=\\\"language-text\\\">string.Concat()</code></li>\\n<li><code class=\\\"language-text\\\">StringBuilder</code></li>\\n<li><code class=\\\"language-text\\\">string.Join()</code></li>\\n</ul>\\n<h1>Simple concatenation</h1>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\"><span class=\\\"token keyword\\\">string</span> a <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"Hello\\\"</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">\\\"World\\\"</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>String concatenation is commonly done using the <code class=\\\"language-text\\\">+</code> operator and passing one or two strings as its operands. Notice that something like <code class=\\\"language-text\\\">string a = &quot;abc&quot; + new FileLoadException();</code> is perfectly legal: you’ll see in a bit why this is.</p>\\n<p>You might have been wondering what happens exactly when you use this form of concatenation. In order to find out, we have to look at the generated IL code. Now, if you simply look at the generated IL given the string above you will notice that it looks like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">IL_0000: nop\\nIL_0001: ldstr &quot;HelloWorld&quot;\\nIL_0006: stloc.0 // a\\nIL_0007: ret</code></pre>\\n      </div>\\n<p>Because our string concatenation is considered a so-called “compile-time constant expression” the compiler turns it into a single string for us already.</p>\\n<p>We can bypass this optimization by defining it as two separate variables and concatenating these:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\"><span class=\\\"token keyword\\\">string</span> x <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"Hello\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">string</span> y <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"World\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">string</span> a <span class=\\\"token operator\\\">=</span> x <span class=\\\"token operator\\\">+</span> y<span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>Looking at the IL again we now see this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">IL_0000: nop\\nIL_0001: ldstr &quot;Hello&quot;\\nIL_0006: stloc.0 // x\\nIL_0007: ldstr &quot;World&quot;\\nIL_000C: stloc.1 // y\\nIL_000D: ldloc.0 // x\\nIL_000E: ldloc.1 // y\\nIL_000F: call System.String.Concat\\nIL_0014: stloc.2 // a\\nIL_0015: ret</code></pre>\\n      </div>\\n<p>That’s more like it! We can tell from this that first the two strings are loaded into memory (separately!) and, more interestingly, they are put together using the <code class=\\\"language-text\\\">string.Concat()</code> method.</p>\\n<h1>string.Concat()</h1>\\n<p>We’ve seen now that simple string concatenation results in a call to <code class=\\\"language-text\\\">string.Concat()</code>. Depending on the types passed in it will choose between <code class=\\\"language-text\\\">string.Concat(string, string)</code> (in the case of two strings) or <code class=\\\"language-text\\\">string.Concat(object, object)</code> (in the case of only one string). If you’ll replace the simple concatenation with a call to <code class=\\\"language-text\\\">string.Format()</code> you’ll notice that you receive the exact same IL.</p>\\n<p>At this point we can take a look at the internals and what goes on exactly. Looking at <a href=\\\"https://github.com/dotnet/coreclr/blob/d176041723f366c35fd71ee4b176253fefddfee1/src/mscorlib/src/System/String.cs#L3011\\\">the source code</a> of <code class=\\\"language-text\\\">string.Concat(object, object)</code> we can see it is a pass-through to <code class=\\\"language-text\\\">string.Concat(string, string)</code> by calling <code class=\\\"language-text\\\">ToString()</code> on both operands — even if one of these was already a string.</p>\\n<p><a href=\\\"https://github.com/dotnet/coreclr/blob/d176041723f366c35fd71ee4b176253fefddfee1/src/mscorlib/src/System/String.cs#L3141\\\">Our next step</a> is more interesting: after the usual validation handling and fast tracks, we see a few very interesting methods being called:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\"><span class=\\\"token class-name\\\">String</span> result <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">FastAllocateString</span><span class=\\\"token punctuation\\\">(</span>str0Length <span class=\\\"token operator\\\">+</span> str1<span class=\\\"token punctuation\\\">.</span>Length<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">FillStringChecked</span><span class=\\\"token punctuation\\\">(</span>result<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">,</span> str0<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">FillStringChecked</span><span class=\\\"token punctuation\\\">(</span>result<span class=\\\"token punctuation\\\">,</span> str0Length<span class=\\\"token punctuation\\\">,</span> str1<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p><code class=\\\"language-text\\\">FastAllocateString(int)</code> is an external method that will allocate the space needed to concatenate both strings which is evidently the sum of their lengths. Afterwards, <code class=\\\"language-text\\\">FillStringChecked(string, int, string)</code> will copy the contents from the given string (third parameter) at a certain index into the aggregate one we just allocated. At this point the aggregate string is filled and can be returned to the caller. You might have noticed that <code class=\\\"language-text\\\">FastAllocateString</code> returns a string and not a <code class=\\\"language-text\\\">char</code> array. This is important because it changes the way we have to fill it: with a char array we would be able to simply access each entry directly and insert the correct value. However since it is a string we can (have to?) use an unsafe context and pull out some C to copy the contents into the correct memory location. This has as benefit that you don’t have to loop (explicitly) to move the string around.</p>\\n<h2>What about more concatenations?</h2>\\n<p>If you look at the overloads you’ll notice that there are overloads with 2, 3 and 4 parameters and afer that you have to use the one with only one: a collection. We can see this in action when we try to concatenate 5 strings:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\"><span class=\\\"token keyword\\\">string</span> v <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"Strings\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">string</span> w <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"Are\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">string</span> x <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"Fun\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">string</span> y <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"Hello\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">string</span> z <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"World\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">string</span> a <span class=\\\"token operator\\\">=</span> v <span class=\\\"token operator\\\">+</span> w <span class=\\\"token operator\\\">+</span> x <span class=\\\"token operator\\\">+</span> y <span class=\\\"token operator\\\">+</span> z<span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>generates as IL:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">IL_0000:  nop\\nIL_0001:  ldstr       &quot;Strings&quot;\\nIL_0006:  stloc.0     // v\\nIL_0007:  ldstr       &quot;Are&quot;\\nIL_000C:  stloc.1     // w\\nIL_000D:  ldstr       &quot;Fun&quot;\\nIL_0012:  stloc.2     // x\\nIL_0013:  ldstr       &quot;Hello&quot;\\nIL_0018:  stloc.3     // y\\nIL_0019:  ldstr       &quot;World&quot;\\nIL_001E:  stloc.s     04 // z\\nIL_0020:  ldc.i4.5\\nIL_0021:  newarr      System.String\\nIL_0026:  dup\\nIL_0027:  ldc.i4.0\\nIL_0028:  ldloc.0     // v\\nIL_0029:  stelem.ref\\nIL_002A:  dup\\nIL_002B:  ldc.i4.1\\nIL_002C:  ldloc.1     // w\\nIL_002D:  stelem.ref\\nIL_002E:  dup\\nIL_002F:  ldc.i4.2\\nIL_0030:  ldloc.2     // x\\nIL_0031:  stelem.ref\\nIL_0032:  dup\\nIL_0033:  ldc.i4.3\\nIL_0034:  ldloc.3     // y\\nIL_0035:  stelem.ref\\nIL_0036:  dup\\nIL_0037:  ldc.i4.4\\nIL_0038:  ldloc.s     04 // z\\nIL_003A:  stelem.ref\\nIL_003B:  call        System.String.Concat\\nIL_0040:  stloc.s     05 // a\\nIL_0042:  ret</code></pre>\\n      </div>\\n<p>This clearly shows us a new array is created (see instruction <code class=\\\"language-text\\\">IL_0021</code>) which is then passed to the <code class=\\\"language-text\\\">string.Concat()</code> call.\\nThe reason there are these specific overloads for 3 and 4 arguments is performance: the most common scenarios of concatenating values include 2, 3 or 4 operands and as such these are treated separatedly to get performance gains in the majority of cases.</p>\\n<p>For this implementation we have to take a look at the <code class=\\\"language-text\\\">string.Concat(params string[])</code> method. The implementation here is fairly straightforward: just as in the previous methods we calculate the total length of the resulting string and afterwards fill that up with the <code class=\\\"language-text\\\">string.ConcatArray(string[], int)</code> method. Also interesting to notice is the threading consideration by deep-copying the array of strings to a new, local one!</p>\\n<h1>StringBuilder</h1>\\n<p>It’s time to add the notorious <code class=\\\"language-text\\\">StringBuilder</code> to the mix. We’ll work with a very simple scenario:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\"><span class=\\\"token class-name\\\">StringBuilder</span> sb <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">StringBuilder</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nsb<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Append</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Hello\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nsb<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Append</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"World\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">string</span> a <span class=\\\"token operator\\\">=</span> sb<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">ToString</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>A <code class=\\\"language-text\\\">StringBuilder</code> is in essence a wrapper class around an array of chars and each time you append something to it, it inserts the given string’s content (aka: the chars) in the next available space in the <code class=\\\"language-text\\\">StringBuilder</code> array. This follows a similar idea to <code class=\\\"language-text\\\">string.Concat</code> but the big benefit here is that the resulting array is maintained over multiple calls instead of a single call. You might see where I’m going with this: <code class=\\\"language-text\\\">string.Concat()</code> creates a new string object for each call. A <code class=\\\"language-text\\\">StringBuilder</code> however only does this when its <code class=\\\"language-text\\\">ToString()</code> method is called regardless of how often you call <code class=\\\"language-text\\\">StringBuilder.Append()</code>. The more objects you allocate, the more you strain the garbage collector and the sooner you trigger a garbage collection. Nobody likes collecting garbage if it could have been prevented altogether.</p>\\n<p>The obvious real-life scenario is when you use a loop.</p>\\n<h1>string.Join()</h1>\\n<p>Last but not least: <code class=\\\"language-text\\\">string.Join()</code>. Admittedly, this probably isn’t the usecase most people have in mind for this method but since it still fits, I thought it to be interesting to include in this overview. When we look at <a href=\\\"https://github.com/dotnet/coreclr/blob/d176041723f366c35fd71ee4b176253fefddfee1/src/mscorlib/src/System/String.cs#L156\\\">the code</a> we notice something interesting: it uses a <code class=\\\"language-text\\\">StringBuilder</code> internally!</p>\\n<p>I believe you’ll find this to be a common sight: many methods that have to concatenate strings use a StringBuilder internally.</p>\\n<h1>Conclusion</h1>\\n<p>Reflecting on these four approaches we can group them under two actually different ones: <code class=\\\"language-text\\\">string.Concat()</code> and <code class=\\\"language-text\\\">StringBuilder</code>. We’ve also seen that <code class=\\\"language-text\\\">string.Concat()</code> creates a new string each time you concatenate it whereas <code class=\\\"language-text\\\">StringBuilder</code> delays this until the very end and only does it once. On the other hand: constructing a <code class=\\\"language-text\\\">StringBuilder</code> object, adding to it and then retrieving the result is much more verbose than a simple + operator.</p>\\n<p>You will have to decide for yourself what you consider acceptable but I personally only use <code class=\\\"language-text\\\">StringBuilder</code> when I loop over something. If I can do concatenating “manually” and it remains readable then it must mean there are so little strings that it would barely make a difference anyway (don’t forget that the <code class=\\\"language-text\\\">StringBuilder</code> is an object that needs to be allocated as well!).</p>\",\"fields\":{\"tagSlugs\":[\"/tags/c/\",\"/tags/performance/\"]},\"frontmatter\":{\"title\":\"Here be dragons: string concatenation\",\"tags\":[\"C#\",\"Performance\"],\"date\":\"2015-09-17T00:00:00.000Z\",\"description\":\"String concatenation can be done in several ways, each with their own advantages and usecases. In this blogpost I will take a closer look at 4 different ways of concatenating strings and how these are implemented internally. At the end of this post I hope I will have made clear when they are useful, when they are not and how they compare to eachother implementation-wise.\"}}},\"pathContext\":{\"slug\":\"/posts/here-be-dragons-string-concatenation/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/posts-here-be-dragons-string-concatenation.json\n// module id = 433\n// module chunks = 267124642010291"],"sourceRoot":""}